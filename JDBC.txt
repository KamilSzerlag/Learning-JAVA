JDBC to skrót od nazwy JAVA DATABASE CONNECTIVITY
jest API (Application Programming Interface), œciœle okreœlony zestaw regu³ i ich opisów, w jaki programy komunikuj¹ siê miêdzy sob¹.
JDBC stanowi pomost pomiêdzy aplikacj¹ i Ÿród³em danych np. Baz¹ danych. 
Aby u¿yæ Ÿród³a danych w aplikacji niezbêdne jest u¿ycie sterownika JDBC (JDBC driver).
I tak aby otrzymaæ dostêp do bazy danych SQLite niezbêdny jest "sqlite JDBC driver". 
Sterownik(driver) jest to biblioteka JAVAy zawieraj¹ca klasy implementuj¹ce JDBC API
JDBC zawiera dwie paczki: 
java.sql (rdzeñ JDBC/core JDBC) i javax.sql(optiona JDBC)
javax.sql jest wymagany do pracy z bazami danych na serwerach.

U¿ywaj¹c sqlite do ³¹czenia z baza danych nie wymgane jest aby baza utworzona by³a wczeœniej. sqlite utworzy j¹ za nas.

Bazy danych wymagaj¹ odpowiednich informacji w formie stringów.

W celu po³¹czenia siê z baz¹ danych u¿ywamy DriverManager'a:

    public static void main(String[] args) {
        try {
            Connection conn = DriverManager.getConnection("jdbc:sqlite:C:\\Users\\szerlag\\Desktop\\Programowanie\\Java z Udemy\\Bazy danych i Java\\Databases\\JDBCtest\\testjdbc.db");

        } catch (SQLException e) {
            System.out.println("Something went wrong: " + e.getMessage() );
        }

    }
}

Zaleca siê aby pisaæ blok 'try' w nowym stylu, gdy¿ wtedy zasoby automatycznie zostaj¹ zamkniête po wykonaniu bloku: 
   try (Connection conn = DriverManager.getConnection("jdbc:sqlite:C:\\Users\\szerlag\\Desktop\\Programowanie\\Projekty\\INTELIJ\\JDBClearn\\testJDBC.db");
             Statement statement = conn.createStatement()) {
            statement.execute("CREATE TABLE kontakty (imie text, nazwisko text, wiek integer)"); {  statement.execute("CREATE TABLE kontakty (imie text, nazwisko text, wiek integer)");}
catch(SQLException e) {} 

CRUD = (Create Read Update Delete)

Wysy³anie zapytañ: 
Statement statement = conn.createStatement();
statement.execute("CREATE TABLE IF NOT EXISTS kontakty" +
                    "   (imie text, nazwisko text, wiek integer)");


Pobieranie rezultatów z bazy danych: 
ResultSet results = statement.executeQuery("SELECT * FROM kontakty");

Otrzymywanie danych z odpowiedniej kolumny: 
results.getString("column_name"); 

U¿ywanie instancji obiektów Statement nie jest dobr¹ praktyk¹ i przy du¿ej liczbie zapytañ mo¿e miec du¿y wp³yw na wydajnoœæ naszej bazy danych.

W œrodowisku enterprise/przedsiêbiorczym bêdziemy korzystaæ raczej z obiektów typu Prepared.

SQLInjection polega na zastosowaniu jêzyka SQL w polu adresu, has³a, i u¿ycia warunku, który zawsze jest prawdziwy np.  "1=1". Mo¿e to spowodowaæ zwrócienie wszystkich wyników jakie utrzymywane s¹ w bazie danych.
W tym przypadku bezpieczniejsze jest stosowanie metody PreparedStatement która dopuszcza tylko stosowanie litera³ów. 


Najwa¿niejsz¹ cech¹ PreparedStatement jest to i¿ mo¿emy wype³niæ j¹ parametrami unikaj¹c w ten sposób HARD Codingu. 
Miejsce w którym zostanie zaimplementowany parametr symobolizuje '?' 

Tworzenie obiektu PreparedStatement:
String updateString =
    "update " + dbName + ".COFFEES " +
    "set SALES = ? where COF_NAME = ?";
updateSales = con.prepareStatement(updateString);

Wype³nianie wartoœciami:
Schemat:
updateSales.setInt(1, e.getValue().intValue());
updateSales.setString(2, e.getKey());

Przyk³ad:
updateSales.setInt(1, 100);
updateSales.setString(2, "French_Roast");
updateSales.executeUpdate();


Korzystanie z PreparedStatement: 
1. Deklaracja sta³ych wyra¿eñ SQL np:
 public static final String QUERY_ALBUMS_BY_ARTIST_START =
            "SELECT " + TABLE_ALBUMS + '.' + COLUMN_ALBUM_NAME + " FROM " + TABLE_ALBUMS +
                    " INNER JOIN " + TABLE_ARTISTS + " ON " + TABLE_ALBUMS + "." + COLUMN_ALBUM_ARTIST +
                    " = " + TABLE_ARTISTS + "." + COLUMN_ARTIST_ID +
                    " WHERE " + TABLE_ARTISTS + "." + COLUMN_ARTIST_NAME + " = \"";
2. Stworzenie instancji PreparedStatement u¿ywaj¹c:
Connection.prepareStatement(sqlStmtString);
3. Wywo³anie odpowiedniej metody metody set:
updateSales.setInt(1, e.getValue().intValue());
updateSales.setString(2, e.getKey());
4. Wywo³anie wyra¿enia u¿ywaj¹c metody PreparedStatement.execute();
5. Przetwa¿amy resultaty w sposób ten sam jak korzystaj¹c z wyra¿enia Statement

****************WA¯NE********************
TRANSACTIONS (TRANZAKCJE):
Tranzakcje to sekwencja poleceñ SQL które s¹ traktowane jako pojedyñcza jednostka. Je¿eli któreœ z poleceñ nie zostanie wykonane, poprzednie polecena zostan¹ cofniête, bêdŸ teŸ niezapisane. Tak jakby to siê nigdy nie wydarzy³o. ;) 

Je¿eli mówimy o bazach danych to zazwyczaj u¿ywamy s³owa "commit" ni¿ "save/zapisaæ", odnosz¹c siê do permanentnych zmian. 

Baza danych musi mieæ nastêpuj¹ce cechy: 
ACID – zbiór w³aœciwoœci gwarantuj¹cych poprawne przetwarzanie transakcji w bazach danych. ACID jest skrótowcem od angielskich s³ów atomicity, consistency, isolation, durability, czyli niepodzielnoœæ[a], spójnoœæ, izolacja, trwa³oœæ[1].
https://pl.wikipedia.org/wiki/ACID -> Link do Wiki

1. Atomicity(niepodzielnoœæ/atomicznoœæ) - je¿eli jedno polecenie nie zostanie wykonane, wszystkie polecenia zostaj¹ cofniête. 
2. Consistency(spójnoœæ) - Przed rozpoczêciem tranzakcji baza danych posiada poprawny stan. Po zakoñæzeniu tranzakcji baza danych jest wci¹¿ w poprawnym stanie.
3. Isolation(izolacja) - Dopóki nie zostan¹ dokonane zmiany (zacommitowane), nie s¹ widoczne dla innych po³¹czeñ. Tranzakcje nie mog¹ byæ zale¿ne od siebie. 
4. Durability(trwa³oœæ) - Zmiany dokonane przez tranzakcje s¹ permanentne. Je¿eli serwer pada zmiany dokonane przez tranzakcje sa wci¹¿ w bazie danych po ponownym ich uruchomieniu. 

Korzystamy z tranzakcji tylko w przypadku dokonywania zmian w bazie danych. 
Je¿eli nie dokonujemy zmian nie potrzebujemy korzystaæ z tranzakcji. 
Za ka¿dym razem gdy korzystamy z poleceñ UPDATE, INSERT, DELETE powinna byæ dokonywana tranzakcja.

Pracuj¹c z sqlite nastêpuj¹ce komendy s³u¿¹ do obs³ugiwania tranzakcji: 
1. BEGIN TRANSACTION - rêcznie rozpoczynamy tranzakcjê
2. END TRANSACTION - rêcznie koñæzymy tranzakcje. Commit zmian automatycznie koñczy tranzakcjê, z kolei END TRANSACTION powoduje Commit. Mo¿na uznaæ, ¿e END TRANSACTION = COMMIT 
3. COMMIT Powoduje zapisanie zmian utworzonych przez tranzakcjê
4. ROLLBACK - powoduje cofniecie nie zacommitowanych zmian i konczy tranzakcjê. Nale¿y zauwa¿yæ i¿ mo¿emy cofn¹c tylko zmiany maj¹ce miejsce od ostaniego COMMITu b¹dŸ ROLLBACKu. 

Zamykaj¹c po³¹czenie przed dokonaniem commitu, zmiany zostaj¹ cofniête.

!JEDNAK U¯YWAJ¥C JDBC NIE KORZYSTAMY Z TRANZAKCJI-POWI¥ZANYCH POLECANIAMI SQL, A U¯YWAMY OBIEKTU STATEMENT TO WYKONYWANIA ICH!

Aby dokonaæ tranzakcji przy pomocy JDBC musimy pod¹¿aæ z nastêpuj¹cymi krokami: 
1. Wy³¹czamy default-owo ustawiony auto-commit-> Connection.setAutoCommit(false);
2. Uruchamiamy operacje SQL tworz¹ce nasz¹ tranzakcjê
3. Je¿eli nie ma b³êdów wywo³ujemy Connection.commit();, je¿eli s¹ b³êdy wywo³ujemy Connection.rollback();
4. Przywracamy defaultow¹ wartoœc auto-commit->  Connection.setAutoCommit(true); 

